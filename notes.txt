TestNG Annotations
==================
@Test denotes a method as test case

If no testsuite was specified, then testng will create a temp testsuite on its own
it calls it default testsuite

For slf4j issues, you always need at least 2:
the main api, and the 2nd+ libs you need, for example

<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>2.0.3</version>
</dependency>
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-nop</artifactId>
    <version>2.0.3</version>
    <scope>test</scope>
</dependency>

Assertions
==========
Assert.assertEquals(1, 2, "hello asset");
adding a message to the asset output is good, it help with issue triage later

there are many other Asserts, we have (most widely used)
assertTrue
assertFalse
assetNull
assertNotEquals

When an assertions fails, the test is aborted, the method exists but not the classes
i.e if a class has other test methods, they will execute as well

however, when a method exists, all remaining intructions in it do not get executed

These assertions are called "hard assertions"

Soft Assertions
---------------
SoftAssert sa = new SoftAssert();
the you use the object "sa" instead of "Assert"
But if you run the test as is, the test will show as passing
at the end of the method, you must call assertAll()
sa.assertAll()

Basic Annotations
=================
@BeforeMethod
public void setUp(){...}
method name does not have to be setUp, what is important is the annotation
=> called before every method

@AfterMethod
public void tearDown(){...}
=> called after every method
=> will be called even if method exits because of a hard assertion failure

We use these methods to avoind code repetition

@BeforeClass => executes before any method in the class executes, including @BeforeMethod
@AfterClass => executes after the last method in the class executes, include the @AfterMethod

TestNg XML Config
=================
Example:
<suite name="sanity test suite">
    <test name="release 2019.5 testing">
        <classes>
            <class name="com.project.tests.EBayHomeSanity"></class>
            <class name="com.project.tests.EBayHomeSanitySoftAssert"></class>
            <class name="com.project.pages.EBayHomeSanityMain"></class>
        </classes>
    </test>
</suite>

A suite can have mutiple <test>
a <test> can have multiple classes in it
test here refers to the testing type we are performing

so for testNG, the class is not considered a Suite

For the full possible Configs using the XML file, refer to:
https://testng.org/doc/documentation-main.html#testng-xml

and
https://testng.org/doc/documentation-main.html#methods

IMPORTANT: you can point to any package you want, it does not have to be in the Test Sources Root Directory "test/java"

For example, the below test class is in main/java
<class name="com.project.pages.EBayHomeSanityMain"></class>

=> you might need this if you want to package your tests in a jar, as the "test" Directory normally gets ingnored when packaging the jar file

specifying select methods to run
<class name="test.Test1">
  <methods>
    <include name="m1" />
    <include name="m2" />
  </methods>
</class>

we also have <exclude>

More Annotations
================

<suite name="sanity test suite"> => @BeforeSuite and @AfterSuite
    <test name="release 2019.5 testing"> => @BeforeTest and @AfterTest

For page Factory in Selenium
============================
The below is for PageFactory
----------------------------
create a class TestObjectClassElements
then set the locators: 
@FindBy(css="...") public WebElement myButton, this is a css locator, there are other types of locators
and a driver
WebDriver driver;

then in the constructor
public TestObjectClassElements(WebDriver driver) {
  this.driver = driver;
  PageFactory.initElements(driver, this);
}

Then when you need it, simply call it instantiate a new TestObjectClassElements object
Usually 1 Class containing all the elements per page as well, it can be split into multiple classes of course

PageObjectModel
---------------
You do no call the elements from the PageFactory class directly, you need 1 more middle layer

TestObjectClassPage -> 1 class per page

create the class, declare the web elements you want to use, usually 1 Class containing all the elements per page as well
Then you define a method per action that the user does, or event a method

public class TestObjectClassPage {
  WebDriver driver;
  TestObjectClassElements elements;

  public TestObjectClassPage(WebDriver driver) {
    this.driver = driver;
    this.elements = new TestObjectClassElements(driver);
  }

  //Then you define a method per action that the user does
  public void clickSearchButton() {
    
  }
}

Then in the test, you use the TestObjectClassPage to do the work

When doing an action, there no need to return, so public void myAction() {...}
When doind a check, we need to return the status/data of the element being fetched, for example:
public boolean isSearchButtonEnabled() {
  return this.elements.searchButton.isEnabled();
}

So to summarize:
ElementsClass -> PageClass -> TestClass
it is a 3 layer structure

Automation Framework Design
===========================
Base Test Class
---------------
Create a base class that contains the setups and teardowns
better make the class as abstract, as normally, it only contains setup and teardowns

@BeforeX and @AfterX methods get inherited with their annotations

in the base test class, we do not go about creating the pages, instead we group them in Libraries

Page Library
------------
The page Library is simply a class (say we call it PageLib) that instantiates TestObjectClassPage objects and has getter methods that return them
Most of these class require a driver, so you will be passing it nearly everyWhere

Then we create an app Library class (say we call it AppLib) that instantiates the PageLib class (and other page Library classes)
with getter method to return the PageLib object

then in te base class, we create an object of AppLib

The in the abstract base test class
we instantiate an AppLib Object
and we add a getter method to returns the AppLib Object

So to summarize (UPDATED):
ElementsClass -> PageClass -> PageLib -> AppLib -> abstract BaseTestClass -> TestClass

Flow Library
------------
a flow library encapsulates the code related to navigating to a uLR

public void visitUrl(String url) {
  this.driver.get(url)
}

so you create said class, then you instantiate it in the AppLib class
AppLib is alwasy the entry point for everything