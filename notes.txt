TestNG Annotations
==================
@Test denotes a method as test case

If no testsuite was specified, then testng will create a temp testsuite on its own
it calls it default testsuite

For slf4j issues, you always need at least 2:
the main api, and the 2nd+ libs you need, for example

<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>2.0.3</version>
</dependency>
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-nop</artifactId>
    <version>2.0.3</version>
    <scope>test</scope>
</dependency>

Assertions
==========
Assert.assertEquals(1, 2, "hello asset");
adding a message to the asset output is good, it help with issue triage later

there are many other Asserts, we have (most widely used)
assertTrue
assertFalse
assetNull
assertNotEquals

When an assertions fails, the test is aborted, the method exists but not the classes
i.e if a class has other test methods, they will execute as well

however, when a method exists, all remaining intructions in it do not get executed

These assertions are called "hard assertions"

Soft Assertions
---------------
SoftAssert sa = new SoftAssert();
the you use the object "sa" instead of "Assert"
But if you run the test as is, the test will show as passing
at the end of the method, you must call assertAll()
sa.assertAll()

Basic Annotations
=================
@BeforeMethod
public void setUp(){...}
method name does not have to be setUp, what is important is the annotation
=> called before every method

@AfterMethod
public void tearDown(){...}
=> called after every method
=> will be called even if method exits because of a hard assertion failure

We use these methods to avoind code repetition

@BeforeClass => executes before any method in the class executes, including @BeforeMethod
@AfterClass => executes after the last method in the class executes, include the @AfterMethod